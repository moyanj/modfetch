"""
配置数据模型

定义 ModFetch 的所有配置相关数据类。
"""

import aiohttp
import json
import yaml
import toml
from typing import List, Optional, Union, Dict, Any
from dataclasses import dataclass, field
from enum import Enum


class ModLoader(Enum):
    """模组加载器类型"""

    FORGE = "forge"
    NEOFORGE = "neoforge"
    FABRIC = "fabric"
    QUILT = "quilt"


class OutputFormat(Enum):
    """输出格式"""

    ZIP = "zip"
    MRPACK = "mrpack"


class FileType(Enum):
    """文件类型"""

    MOD = "mod"
    FILE = "file"
    RESOURCEPACK = "resourcepack"
    SHADERPACK = "shaderpack"


@dataclass
class ConditionalEntry:
    """条件配置项基类"""

    only_version: Optional[Union[str, List[str]]] = None
    feature: Optional[Union[str, List[str]]] = None


@dataclass
class ModEntry(ConditionalEntry):
    """模组配置项"""

    id: Optional[str] = None
    slug: Optional[str] = None
    condition: Optional[ConditionalEntry] = None

    def __post_init__(self):
        if not self.id and not self.slug:
            raise ValueError("ModEntry 必须提供 id 或 slug")


@dataclass
class ExtraUrl(ConditionalEntry):
    """额外下载链接配置"""

    url: str = ""
    filename: Optional[str] = None
    type: FileType = FileType.FILE
    sha1: Optional[str] = None
    condition: Optional[ConditionalEntry] = None

    def __post_init__(self):
        if not self.url:
            raise ValueError("ExtraUrl 必须提供 url")
        if self.filename is None:
            # 从 URL 自动提取文件名
            self.filename = self.url.split("/")[-1]


@dataclass
class ParentConfig:
    """父配置引用"""

    url: str = ""
    format: str = "toml"  # toml/json/yaml/xml

    def __post_init__(self):
        if not self.url:
            raise ValueError("ParentConfig 必须提供 url")
        if self.format not in ["toml", "json", "yaml", "xml"]:
            raise ValueError(f"不支持的配置格式: {self.format}")


@dataclass
class MinecraftConfig:
    """Minecraft 相关配置"""

    version: List[str] = field(default_factory=list)
    mod_loader: ModLoader = ModLoader.FABRIC
    mods: List[Union[str, ModEntry]] = field(default_factory=list)
    resourcepacks: List[Union[str, ModEntry]] = field(default_factory=list)
    shaderpacks: List[Union[str, ModEntry]] = field(default_factory=list)
    extra_urls: List[ExtraUrl] = field(default_factory=list)

    def __post_init__(self):
        if not self.version:
            raise ValueError("MinecraftConfig 必须提供 version")
        if (
            not self.mods
            and not self.resourcepacks
            and not self.shaderpacks
            and not self.extra_urls
        ):
            raise ValueError("MinecraftConfig 必须提供至少一个 模组、资源包或 shader")


@dataclass
class OutputConfig:
    """输出配置"""

    download_dir: str = "downloads"
    format: List[OutputFormat] = field(default_factory=lambda: [OutputFormat.ZIP])

    def __post_init__(self):
        if not self.download_dir:
            self.download_dir = "downloads"


@dataclass
class MetadataConfig:
    """元数据配置"""

    name: str = "ModFetch Pack"
    version: str = "1.0.0"
    description: str = "A modpack generated by ModFetch"


@dataclass
class ModFetchConfig:
    """ModFetch 主配置类"""

    # 必需配置段
    minecraft: MinecraftConfig = field(default_factory=MinecraftConfig)

    # 可选配置段
    output: OutputConfig = field(default_factory=OutputConfig)
    metadata: MetadataConfig = field(default_factory=MetadataConfig)

    # 其他配置
    max_concurrent: int = 5
    max_retries: int = 3
    retry_delay: float = 1.0  # 初始重试延迟（秒）
    features: List[str] = field(default_factory=list)
    parent_configs: List[ParentConfig] = field(default_factory=list)

    # 原始配置字典（用于向后兼容）
    _raw_config: Dict[str, Any] = field(default_factory=dict, repr=False)

    @classmethod
    async def load_with_inheritance(
        cls,
        config_dict: Dict[str, Any],
        session: Optional[aiohttp.ClientSession] = None,
    ) -> "ModFetchConfig":
        """异步加载带继承逻辑的配置"""
        merged_dict = await cls._resolve_inheritance(config_dict, session)
        return cls.from_dict(merged_dict)

    @classmethod
    async def _resolve_inheritance(
        cls,
        config_dict: Dict[str, Any],
        session: Optional[aiohttp.ClientSession] = None,
    ) -> Dict[str, Any]:
        """递归解析继承逻辑"""
        parent_refs = config_dict.get("from")
        if not parent_refs:
            return config_dict

        if isinstance(parent_refs, dict):
            parent_refs = [parent_refs]

        # 存储所有父配置的字典
        parent_dicts = []

        close_session = False
        if session is None:
            session = aiohttp.ClientSession()
            close_session = True

        try:
            for ref in parent_refs:
                url = ref.get("url")
                fmt = ref.get("format", "toml")
                if not url:
                    continue

                async with session.get(url) as response:
                    if response.status != 200:
                        raise ValueError(
                            f"无法加载父配置: {url} (状态码: {response.status})"
                        )
                    content = await response.text()

                if fmt == "toml":
                    parent_dict = toml.loads(content)
                elif fmt == "json":
                    parent_dict = json.loads(content)
                elif fmt == "yaml" or fmt == "yml":
                    parent_dict = yaml.safe_load(content)
                else:
                    raise ValueError(f"不支持的配置格式: {fmt}")

                # 递归解析父配置的继承
                resolved_parent = await cls._resolve_inheritance(parent_dict, session)
                parent_dicts.append(resolved_parent)
        finally:
            if close_session:
                await session.close()

        # 合并逻辑：从最远的父配置开始合并到当前配置
        final_dict = {}
        for p_dict in parent_dicts:
            final_dict = cls._merge_dicts(final_dict, p_dict)

        # 最后合并当前配置
        final_dict = cls._merge_dicts(final_dict, config_dict)
        return final_dict

    @classmethod
    def _merge_dicts(
        cls, base: Dict[str, Any], overlay: Dict[str, Any]
    ) -> Dict[str, Any]:
        """合并两个配置字典"""
        result = base.copy()

        for key, value in overlay.items():
            if key == "from":
                continue

            if (
                key in result
                and isinstance(result[key], dict)
                and isinstance(value, dict)
            ):
                result[key] = cls._merge_dicts(result[key], value)
            elif (
                key in result
                and isinstance(result[key], list)
                and isinstance(value, list)
            ):
                # 列表合并去重
                # 注意：对于复杂的对象列表（如 mods），简单的 set 去重可能不够
                # 但根据要求，我们需要合并去重
                combined = result[key] + value
                seen = []
                for item in combined:
                    if item not in seen:
                        seen.append(item)
                result[key] = seen
            else:
                # 单值字段：overlay 覆盖 base
                result[key] = value

        return result

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "ModFetchConfig":
        """从字典创建配置对象"""

        # 保存原始配置
        raw_config = config_dict.copy()

        # 处理父配置引用
        parent_configs = []
        parent_refs = config_dict.pop("from", None)
        if parent_refs:
            if isinstance(parent_refs, dict):
                parent_refs = [parent_refs]
            for ref in parent_refs:
                parent_configs.append(
                    ParentConfig(
                        url=ref.get("url", ""), format=ref.get("format", "toml")
                    )
                )

        # 处理 Minecraft 配置
        mc_dict = config_dict.get("minecraft", {})
        minecraft_config = MinecraftConfig(
            version=mc_dict.get("version", []),
            mod_loader=ModLoader(mc_dict.get("mod_loader", "fabric")),
            mods=cls._parse_mod_entries(mc_dict.get("mods", [])),
            resourcepacks=cls._parse_mod_entries(mc_dict.get("resourcepacks", [])),
            shaderpacks=cls._parse_mod_entries(mc_dict.get("shaderpacks", [])),
            extra_urls=cls._parse_extra_urls(mc_dict.get("extra_urls", [])),
        )

        # 处理输出配置
        output_dict = config_dict.get("output", {})
        output_config = OutputConfig(
            download_dir=output_dict.get("download_dir", "downloads"),
            format=[OutputFormat(fmt) for fmt in output_dict.get("format", ["zip"])],
        )

        # 处理元数据配置
        metadata_dict = config_dict.get("metadata", {})
        metadata_config = MetadataConfig(
            name=metadata_dict.get("name", "ModFetch Pack"),
            version=metadata_dict.get("version", "1.0.0"),
            description=metadata_dict.get("description", ""),
        )

        return cls(
            minecraft=minecraft_config,
            output=output_config,
            metadata=metadata_config,
            max_concurrent=config_dict.get("max_concurrent", 5),
            max_retries=config_dict.get("max_retries", 3),
            retry_delay=config_dict.get("retry_delay", 1.0),
            features=config_dict.get("features", []),
            parent_configs=parent_configs,
            _raw_config=raw_config,
        )

    @staticmethod
    def _parse_mod_entries(
        entries: List[Any],
    ) -> List[Union[str, ModEntry]]:
        """解析模组条目"""
        result = []
        for entry in entries:
            if isinstance(entry, str):
                result.append(entry)
            elif isinstance(entry, dict):
                result.append(
                    ModEntry(
                        id=entry.get("id"),
                        slug=entry.get("slug"),
                        only_version=entry.get("only_version"),
                        feature=entry.get("feature"),
                    )
                )
            else:
                raise ValueError(f"无效的模组条目类型: {type(entry)}")
        return result

    @staticmethod
    def _parse_extra_urls(urls: List[Any]) -> List[ExtraUrl]:
        """解析额外 URL 配置"""
        result = []
        for url_entry in urls:
            if isinstance(url_entry, dict):
                result.append(
                    ExtraUrl(
                        url=url_entry.get("url", ""),
                        filename=url_entry.get("filename"),
                        type=FileType(url_entry.get("type", "file")),
                        sha1=url_entry.get("sha1"),
                        only_version=url_entry.get("only_version"),
                        feature=url_entry.get("feature"),
                    )
                )
            else:
                raise ValueError(f"无效的 extra_urls 条目类型: {type(url_entry)}")
        return result

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典格式"""
        return {
            "minecraft": {
                "version": self.minecraft.version,
                "mod_loader": self.minecraft.mod_loader.value,
                "mods": self._serialize_mod_entries(self.minecraft.mods),
                "resourcepacks": self._serialize_mod_entries(
                    self.minecraft.resourcepacks
                ),
                "shaderpacks": self._serialize_mod_entries(self.minecraft.shaderpacks),
                "extra_urls": [
                    {
                        "url": url.url,
                        "filename": url.filename,
                        "type": url.type.value,
                        "sha1": url.sha1,
                        "only_version": url.only_version,
                        "feature": url.feature,
                    }
                    for url in self.minecraft.extra_urls
                ],
            },
            "output": {
                "download_dir": self.output.download_dir,
                "format": [fmt.value for fmt in self.output.format],
            },
            "metadata": {
                "name": self.metadata.name,
                "version": self.metadata.version,
                "description": self.metadata.description,
            },
            "max_concurrent": self.max_concurrent,
            "max_retries": self.max_retries,
            "retry_delay": self.retry_delay,
            "features": self.features,
            "from": (
                [
                    {"url": parent.url, "format": parent.format}
                    for parent in self.parent_configs
                ]
                if self.parent_configs
                else None
            ),
        }

    @staticmethod
    def _serialize_mod_entries(
        entries: List[Union[str, ModEntry]],
    ) -> List[Any]:
        """序列化模组条目"""
        result = []
        for entry in entries:
            if isinstance(entry, str):
                result.append(entry)
            else:
                entry_dict = {}
                if entry.id:
                    entry_dict["id"] = entry.id
                if entry.slug:
                    entry_dict["slug"] = entry.slug
                if entry.only_version:
                    entry_dict["only_version"] = entry.only_version
                if entry.feature:
                    entry_dict["feature"] = entry.feature
                result.append(entry_dict)
        return result

    def validate(self) -> None:
        """验证配置完整性"""
        if not self.minecraft.version:
            raise ValueError("必须配置 Minecraft 版本")

        if not self.minecraft.mods:
            raise ValueError("必须配置至少一个模组")

        if self.minecraft.mod_loader not in [
            ModLoader.FORGE,
            ModLoader.FABRIC,
            ModLoader.QUILT,
        ]:
            raise ValueError("mod_loader 必须为 forge/fabric/quilt")

        # 验证所有模组条目
        for i, mod in enumerate(self.minecraft.mods):
            if isinstance(mod, ModEntry) and not mod.id and not mod.slug:
                raise ValueError(f"模组条目 {i} 必须提供 id 或 slug")
