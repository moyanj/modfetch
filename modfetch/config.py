from typing import List, Optional, Union, Dict, Any
from dataclasses import dataclass, field
from enum import Enum


class ModLoader(Enum):
    """模组加载器类型"""

    FORGE = "forge"
    NEOFORGE = "neoforge"
    FABRIC = "fabric"
    QUILT = "quilt"


class OutputFormat(Enum):
    """输出格式"""

    ZIP = "zip"
    MRPACK = "mrpack"


class FileType(Enum):
    """文件类型"""

    MOD = "mod"
    FILE = "file"
    RESOURCEPACK = "resourcepack"
    SHADERPACK = "shaderpack"


@dataclass
class ConditionalEntry:
    """条件配置项基类"""

    only_version: Optional[Union[str, List[str]]] = None
    feature: Optional[Union[str, List[str]]] = None


@dataclass
class ModEntry(ConditionalEntry):
    """模组配置项"""

    id: Optional[str] = None
    slug: Optional[str] = None
    condition: Optional[ConditionalEntry] = None

    def __post_init__(self):
        if not self.id and not self.slug:
            raise ValueError("ModEntry 必须提供 id 或 slug")


@dataclass
class ExtraUrl(ConditionalEntry):
    """额外下载链接配置"""

    url: str = ""
    filename: Optional[str] = None
    type: FileType = FileType.FILE
    sha1: Optional[str] = None
    condition: Optional[ConditionalEntry] = None

    def __post_init__(self):
        if not self.url:
            raise ValueError("ExtraUrl 必须提供 url")
        if self.filename is None:
            # 从 URL 自动提取文件名
            self.filename = self.url.split("/")[-1]


@dataclass
class ParentConfig:
    """父配置引用"""

    url: str = ""
    format: str = "toml"  # toml/json/yaml/xml

    def __post_init__(self):
        if not self.url:
            raise ValueError("ParentConfig 必须提供 url")
        if self.format not in ["toml", "json", "yaml", "xml"]:
            raise ValueError(f"不支持的配置格式: {self.format}")


@dataclass
class MinecraftConfig:
    """Minecraft 相关配置"""

    version: List[str] = field(default_factory=list)
    mod_loader: ModLoader = ModLoader.FABRIC
    mods: List[Union[str, ModEntry]] = field(default_factory=list)
    resourcepacks: List[Union[str, ModEntry]] = field(default_factory=list)
    shaderpacks: List[Union[str, ModEntry]] = field(default_factory=list)
    extra_urls: List[ExtraUrl] = field(default_factory=list)

    def __post_init__(self):
        if not self.version:
            raise ValueError("MinecraftConfig 必须提供 version")
        if (
            not self.mods
            and not self.resourcepacks
            and not self.shaderpacks
            and not self.extra_urls
        ):
            raise ValueError("MinecraftConfig 必须提供至少一个 模组、资源包或 shader")


@dataclass
class OutputConfig:
    """输出配置"""

    download_dir: str = "downloads"
    format: List[OutputFormat] = field(default_factory=lambda: [OutputFormat.ZIP])

    def __post_init__(self):
        if not self.download_dir:
            self.download_dir = "downloads"


@dataclass
class MetadataConfig:
    """元数据配置"""

    name: str = "ModFetch Pack"
    version: str = "1.0.0"
    description: str = "A modpack generated by ModFetch"


@dataclass
class ModFetchConfig:
    """ModFetch 主配置类"""

    # 必需配置段
    minecraft: MinecraftConfig = field(default_factory=MinecraftConfig)

    # 可选配置段
    output: OutputConfig = field(default_factory=OutputConfig)
    metadata: MetadataConfig = field(default_factory=MetadataConfig)

    # 其他配置
    max_concurrent: int = 5
    features: List[str] = field(default_factory=list)
    parent_configs: List[ParentConfig] = field(default_factory=list)

    # 原始配置字典（用于向后兼容）
    _raw_config: Dict[str, Any] = field(default_factory=dict, repr=False)

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "ModFetchConfig":
        """从字典创建配置对象"""

        # 保存原始配置
        raw_config = config_dict.copy()

        # 处理父配置引用
        parent_configs = []
        parent_refs = config_dict.pop("from", None)
        if parent_refs:
            if isinstance(parent_refs, dict):
                parent_refs = [parent_refs]
            for ref in parent_refs:
                parent_configs.append(
                    ParentConfig(
                        url=ref.get("url", ""), format=ref.get("format", "toml")
                    )
                )

        # 处理 Minecraft 配置
        mc_dict = config_dict.get("minecraft", {})
        minecraft_config = MinecraftConfig(
            version=mc_dict.get("version", []),
            mod_loader=ModLoader(mc_dict.get("mod_loader", "fabric")),
            mods=cls._parse_mod_entries(mc_dict.get("mods", [])),
            resourcepacks=cls._parse_mod_entries(mc_dict.get("resourcepacks", [])),
            shaderpacks=cls._parse_mod_entries(mc_dict.get("shaderpacks", [])),
            extra_urls=cls._parse_extra_urls(mc_dict.get("extra_urls", [])),
        )

        # 处理输出配置
        output_dict = config_dict.get("output", {})
        output_config = OutputConfig(
            download_dir=output_dict.get("download_dir", "downloads"),
            format=[OutputFormat(fmt) for fmt in output_dict.get("format", ["zip"])],
        )

        # 处理元数据配置
        metadata_dict = config_dict.get("metadata", {})
        metadata_config = MetadataConfig(
            name=metadata_dict.get("name", "ModFetch Pack"),
            version=metadata_dict.get("version", "1.0.0"),
            description=metadata_dict.get("description", ""),
        )

        return cls(
            minecraft=minecraft_config,
            output=output_config,
            metadata=metadata_config,
            max_concurrent=config_dict.get("max_concurrent", 5),
            features=config_dict.get("features", []),
            parent_configs=parent_configs,
            _raw_config=raw_config,
        )

    @staticmethod
    def _parse_mod_entries(entries: List[Any]) -> List[Union[str, ModEntry]]:
        """解析模组条目"""
        result = []
        for entry in entries:
            if isinstance(entry, str):
                result.append(entry)
            elif isinstance(entry, dict):
                result.append(
                    ModEntry(
                        id=entry.get("id"),
                        slug=entry.get("slug"),
                        only_version=entry.get("only_version"),
                        feature=entry.get("feature"),
                    )
                )
            else:
                raise ValueError(f"无效的模组条目类型: {type(entry)}")
        return result

    @staticmethod
    def _parse_extra_urls(urls: List[Any]) -> List[ExtraUrl]:
        """解析额外 URL 配置"""
        result = []
        for url_entry in urls:
            if isinstance(url_entry, dict):
                result.append(
                    ExtraUrl(
                        url=url_entry.get("url", ""),
                        filename=url_entry.get("filename"),
                        type=FileType(url_entry.get("type", "file")),
                        sha1=url_entry.get("sha1"),
                        only_version=url_entry.get("only_version"),
                        feature=url_entry.get("feature"),
                    )
                )
            else:
                raise ValueError(f"无效的 extra_urls 条目类型: {type(url_entry)}")
        return result

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典格式"""
        return {
            "minecraft": {
                "version": self.minecraft.version,
                "mod_loader": self.minecraft.mod_loader.value,
                "mods": self._serialize_mod_entries(self.minecraft.mods),
                "resourcepacks": self._serialize_mod_entries(
                    self.minecraft.resourcepacks
                ),
                "shaderpacks": self._serialize_mod_entries(self.minecraft.shaderpacks),
                "extra_urls": [
                    {
                        "url": url.url,
                        "filename": url.filename,
                        "type": url.type.value,
                        "sha1": url.sha1,
                        "only_version": url.only_version,
                        "feature": url.feature,
                    }
                    for url in self.minecraft.extra_urls
                ],
            },
            "output": {
                "download_dir": self.output.download_dir,
                "format": [fmt.value for fmt in self.output.format],
            },
            "metadata": {
                "name": self.metadata.name,
                "version": self.metadata.version,
                "description": self.metadata.description,
            },
            "max_concurrent": self.max_concurrent,
            "features": self.features,
            "from": (
                [
                    {"url": parent.url, "format": parent.format}
                    for parent in self.parent_configs
                ]
                if self.parent_configs
                else None
            ),
        }

    @staticmethod
    def _serialize_mod_entries(entries: List[Union[str, ModEntry]]) -> List[Any]:
        """序列化模组条目"""
        result = []
        for entry in entries:
            if isinstance(entry, str):
                result.append(entry)
            else:
                entry_dict = {}
                if entry.id:
                    entry_dict["id"] = entry.id
                if entry.slug:
                    entry_dict["slug"] = entry.slug
                if entry.only_version:
                    entry_dict["only_version"] = entry.only_version
                if entry.feature:
                    entry_dict["feature"] = entry.feature
                result.append(entry_dict)
        return result

    def validate(self) -> None:
        """验证配置完整性"""
        if not self.minecraft.version:
            raise ValueError("必须配置 Minecraft 版本")

        if not self.minecraft.mods:
            raise ValueError("必须配置至少一个模组")

        if self.minecraft.mod_loader not in [
            ModLoader.FORGE,
            ModLoader.FABRIC,
            ModLoader.QUILT,
        ]:
            raise ValueError("mod_loader 必须为 forge/fabric/quilt")

        # 验证所有模组条目
        for i, mod in enumerate(self.minecraft.mods):
            if isinstance(mod, ModEntry) and not mod.id and not mod.slug:
                raise ValueError(f"模组条目 {i} 必须提供 id 或 slug")
